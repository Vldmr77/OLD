# Скальперская система

Проект реализует архитектуру скальпирующей торговой платформы в соответствии с ТЗ.

## Основные компоненты

- `scalp_system.config` — описание конфигурации и загрузчик YAML/JSON.
- `scalp_system.data` — потоковая подписка и DataEngine с TTL-кешем, кольцевыми буферами и ротацией инструментов.
- `scalp_system.features` — генерация фич из стакана.
- `scalp_system.ml` — ансамбль моделей (LSTM, GBDT, Transformer, SVM) и формирование сигналов.
- `scalp_system.ml.fallback` — эвристический генератор сигналов при сбоях ML-ансамбля.
- `scalp_system.ml.training` — оффлайн-тренировка ансамбля и подготовка весов моделей.
- `scalp_system.risk` — риск-менеджмент и контроль лимитов.
- `scalp_system.execution` — исполнение заявок через API брокера.
- `scalp_system.broker` — вспомогательные обёртки над tinkoff-investments SDK.
- `scalp_system.monitoring` — детектор дрейфа и метрики.
- `scalp_system.monitoring.audit` — аудит действий в формате W3C.
- `scalp_system.monitoring.resource` — контроль загрузки CPU/GPU/памяти.
- `scalp_system.monitoring.notifications` — Telegram-уведомления и звуковые сигналы.
- `scalp_system.monitoring.reporting` — формирование периодических отчётов по результатам.
- `scalp_system.ml.calibration` — постановка задач калибровки моделей.
- `scalp_system.storage` — SQLite репозиторий для логирования сигналов.
- `scalp_system.ui` — лёгкий встроенный HTTP-дэшборд для просмотра сигналов и состояний.
- `scalp_system.storage.disaster_recovery` — резервные копии критичных артефактов.
- `scalp_system.utils.integrity` — проверки целостности данных при переподключении.
- `scalp_system.security` — менеджер ключей шифрования токенов.

## Запуск

```bash
pip install --no-index tinkoff_investments-0.2.0b117-py3-none-any.whl  # локальная установка SDK
python -m scalp_system config.example.yaml
```

При отсутствии поддержки YAML можно использовать JSON-конфигурацию (`config.json`).

### Работа с tinkoff-investments SDK

Для подписки на рыночные данные и отправки заявок используется официальный SDK. Репозиторий содержит
подписанную версию `tinkoff_investments-0.2.0b117-py3-none-any.whl`. Установите её перед запуском:

```bash
pip install --no-index tinkoff_investments-0.2.0b117-py3-none-any.whl
```

После установки доступны высокоуровневые обёртки `scalp_system.broker.TinkoffAPI`, а также
`MarketDataStream` и `BrokerClient`, которые используются оркестратором и тестами. При отсутствии SDK
будет выброшено понятное исключение с подсказкой по установке.

Для работы с зашифрованными токенами укажите путь к Fernet-ключу в секции `security`,
а сами значения пометьте префиксом `enc:`. Ключ можно создать командой:

```python
from scalp_system.security import KeyManager
key = KeyManager.generate()
print(key.serialise())
```

### UI-дэшборд

Для оперативного контроля состояния реализован лёгкий HTTP-дэшборд без внешних зависимостей. Он читает данные из SQLite
репозитория сигналов и отображает последние записи, а также агрегированную статистику.

Запуск с использованием CLI:

```bash
python -m scalp_system.cli.dashboard --repository ./runtime/signals.sqlite3 --host 0.0.0.0 --port 8000
```

После запуска перейдите в браузере по адресу `http://<host>:<port>/`, чтобы увидеть таблицу сигналов и
резюме. Для интеграции в инфраструктуру дэшборд можно запускать в отдельном процессе либо контейнере.

## Дополнительные утилиты

- `python -m scalp_system.cli.init_config --env production`
- `python -m scalp_system.cli.model_trainer calibrate --config config.example.yaml`
- `python -m scalp_system.cli.model_trainer train --dataset data/training.jsonl --output runtime/models`
- `python -m scalp_system.cli.health_check --config config.example.yaml`
- `python -m scalp_system.cli.backtest config.example.yaml --dataset data/backtest.jsonl --output runtime/reports/backtest.json`

Секция `notifications` конфигурации задаёт параметры Telegram-уведомлений и локальных
звуковых сигналов. При указании токена и идентификатора чата система отправляет
сообщения о исполненных заявках, срабатывании защитных механизмов и предупреждениях о
низкой ликвидности. Порог спреда в bps управляет порогом срабатывания сигналов
с частотами 1.5 кГц (ликвидность) и 2.5 кГц (высокий риск).

Секция `reporting` включает накопление и рассылку оперативных отчётов по реализованному
PnL, динамике доверия сигналов и флагам риска. Параметр `interval_minutes` задаёт период
между выпусками, `report_path` — JSONL-файл с историей (хранится не дольше `max_history_days`).
При каждом выпуске в Telegram отправляется краткая сводка, если настроен бот.

Секция `disaster_recovery` активирует репликацию рабочей директории с сигналами, чекпоинтами
и очередями калибровки в отдельную папку. Параметр `replication_path` определяет каталог с
таймстемпами, `include_patterns` — маски файлов (по умолчанию `*.db`, `*.json`, `*.jsonl`),
`interval_minutes` — минимальный промежуток между копиями, а `max_snapshots` — глубина хранения.
При успешном резервном копировании отправляется уведомление в Telegram, если он включён.

Секция `training` конфигурации описывает путь до JSONL-датасета с историческими примерами,
параметры обучения (число эпох, скорость обучения, размер валидационной выборки) и место
сохранения артефактов. Команда `train` формирует файл `ensemble_weights.json` в указанной
директории, создает отчёт `*.training.json` с метриками и генерирует план квантования
`quantization_plan.json` (INT8 для весов выше порога, FLOAT16 для остальных моделей).

Секция `backtest` задаёт набор параметров для оффлайн-проверок стратегии: путь до
исторического JSONL с ордербуками, стартовый капитал, допущения по комиссионным и лимит
на количество симулированных заявок. CLI-команда `backtest` читает указанный датасет,
генерирует фичи/сигналы теми же пайплайнами, что и боевая система, и сохраняет JSON-отчёт
с PnL, долей прибыльных сделок и эквити-кривой.

Секция `system` управляет режимом (`mode`), временем планового старта (`startup_time`) и
частотой сохранения чекпоинтов (`checkpoint_interval_seconds`). Актуальное состояние
риск-движка и активных инструментов сохраняется в `runtime/checkpoint.json` и восстанавливается
при следующем запуске. Параметры `latency_thresholds` и `latency_violation_limit` позволяют
поднять аварийное уведомление или остановку торгов при деградации задержек этапов `features`,
`ml` и `risk`.

Секция `manual_override` добавляет ручной стоп торгов: при наличии файла-флага (по умолчанию
`runtime/manual_override.flag`) оркестратор продолжает приём маркет-даты и обновление кешей,
но не отправляет заявки. Содержимое файла используется как причина остановки и попадает в
аудит/уведомления. Укажите `auto_resume_minutes`, чтобы флаг автоматически очищался по
истечении заданного времени, либо удалите файл вручную/через CLI утилиту. Интервал опроса
регулируется параметром `poll_interval_seconds`.

Секция `session` вводит расписание торгов. При `enabled: true` система проверяет, попадает ли
текущее время в окно между `start_time` и `end_time` с учётом буферов `pre_open_minutes` и
`post_close_minutes`. В выходные или неразрешённые дни (`allowed_weekdays`) торговля
приостанавливается, в аудит пишутся события `SESSION_SUSPENDED/SESSION_RESUMED`, а в Telegram
приходит уведомление с временем следующего окна.

Секция `risk` задаёт исходный капитал (`capital_base`), долю риска на инструмент
(`max_risk_per_instrument`), суточный процентный стоп (`daily_loss_limit_pct`), ограничение на
экспозицию (`max_exposure_pct`) и порог волатильности (`vix_threshold`). Эти параметры используются
для расчёта размера позиции и проверки лимитов вместе с абсолютными значениями `max_daily_loss` и
`max_gross_exposure`.

## Торговый маршрут

- Для каждого сигнала риск-движок формирует `OrderPlan`: рассчитывает стоп-лосс по формуле
  `stop_loss = entry_price * (1 + (1.8 * atr5 + 0.5 * spread) * direction)` и определяет объём с
  учётом доли капитала, доступного лимита позиций и экспозиции.
- Если итоговый объём превышает пять лотов, ExecutionEngine разбивает сделку на VWAP-стратегию:
  80% объёма исполняется рыночным ордером, остаток уходит лимитом с лёгким улучшением цены.
- При меньших объёмах используется IOC-маркет-ордер. После исполнения риск-движок фиксирует
  рассчитанный стоп-лосс в состоянии позиции и обновляет счётчики заявок.
- При превышении `vix_threshold` (например, VIXMOEX >40%) торговля переводится в аварийный стоп до
  ручного возобновления.

Секция `fallback` описывает эвристический генератор сигналов на случай недоступности
ML-ансамбля. При ошибке инференса или пустом ответе проверяется дисбаланс объёма и
волатильность последнего окна стаканов; если они превышают пороги `imbalance_threshold`
и `volatility_threshold`, формируется сигнал с уверенностью `confidence`. Лимит
`max_signals_per_hour` предотвращает деградацию стратегии, а исчерпание квоты фиксируется
как событие `FALLBACK_UNAVAILABLE`.

Секция `connectivity` задаёт фейловер канала связи: при превышении `failure_threshold`
ошибок поток автоматически переключается на LTE за `failover_latency_ms` (по умолчанию 150 мс),
очищает кеши стаканов, инициирует резервную подписку и отправляет уведомление
`CONNECTIVITY_FAILOVER`. После `recovery_message_count` успешных сообщений канал возвращается
к основному и испускает `CONNECTIVITY_RECOVERED`.

Секция `monitoring` управляет порогами ресурсов и heartbeat-контролем. При включении
`heartbeat_enabled` оркестратор ожидает, что хотя бы раз в `heartbeat_interval_seconds`
поступит стакан. Если зафиксировано `heartbeat_miss_threshold` подряд пропусков, торговля
останавливается, в аудит пишется событие `HEARTBEAT_MISSED`, а в уведомления уходит причина
последней ошибки подключения.

## Риск-менеджмент

- `max_daily_loss` — убыток, после которого торговля останавливается до следующего дня.
- `loss_cooldown_minutes` и `max_consecutive_losses` — охлаждение стратегии после серии
  убыточных сделок; в течение тайм-аута новые сигналы отвергаются.
- Реализованный PnL пересчитывается при частичном и полном закрытии позиций, что позволяет
  корректно отслеживать просадки даже при реверсе позиции.
- После полуночного ролловера все дневные счётчики сбрасываются, но остановка из-за
  критического дрейфа снимается только после `notify_model_reload()`.

## Мониторинг и калибровка

- Метрики дрейфа сохраняются в `runtime/drift_metrics/drift_metrics_YYYYMMDD.jsonl`.
- Триггеры на калибровку пишутся в `runtime/calibration_queue.jsonl` с дедупликацией.
- Резервные копии сигналов сохраняются в `runtime/signals.fallback.jsonl`, кеш состояния сбрасывается адаптивно с интервалом 1–5 секунд в зависимости от нагрузки.
- Перезагрузка моделей очищает кэш фич, валидирует TFLite файлы и уведомляет RiskEngine.
- Аудит действий пишется в формате W3C (`runtime/audit.log`) с тегами `ORDER`, `RISK`, `RESOURCE`.
- Монитор ресурсов переводит систему в упрощённый режим при превышении лимитов CPU/GPU/памяти.
- Контроль задержек фиксирует превышения порогов по этапам `features`, `ml`, `risk`, отправляет
  уведомления и при повторных срабатываниях переводит RiskEngine в аварийный стоп.
- Heartbeat-мониторинг отслеживает паузы в поставке стаканов и после нескольких пропусков
  останавливает торговлю, фиксируя событие `HEARTBEAT_MISSED` и причину последнего сбоя.
- При сбое GPU инференс LSTM автоматически переводится на CPU, частота снижается до 5 Гц,
  кеши фич сбрасываются, а в уведомления уходит сообщение `GPU_FAILOVER mode=cpu`.
- Эвристический fallback-модуль подстраховывает ансамбль: при успешной выдаче
  `FALLBACK_SIGNAL` в аудит записываются дисбаланс и волатильность, а в Telegram отправляется
  уведомление; при невозможности сформировать сигнал фиксируется `FALLBACK_UNAVAILABLE`.
